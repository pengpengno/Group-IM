import com.github.im.group.db.entities.MessageStatus;
import com.github.im.group.db.entities.MessageType;
import com.github.im.group.db.entities.UserStatus;
import kotlinx.datetime.LocalDateTime;

CREATE TABLE message (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- 客户端存储的消息 自增即可
    msg_id  INTEGER ,  -- 服务端的主键 消息Id
    conversation_id INTEGER NOT NULL,  -- 外键保存 conversationId
    from_account_id INTEGER NOT NULL,  -- 外键保存 userId
    content TEXT NOT NULL,
    client_msg_id TEXT,  -- 客户端生成的消息id ，配合 sequence_id 唯一使用
    sequence_id INTEGER ,   -- 服务端生成的 conversation 下的序列号 发送完毕
    type TEXT AS MessageType NOT NULL DEFAULT 'TEXT',             -- MessageType
    status TEXT AS MessageStatus NOT NULL DEFAULT 'SENDING',           -- MessageStatus
    client_timestamp INTEGER AS LocalDateTime,       --  本地客户端发送时间 ， 只有自己发送的消息需要这个
    server_timestamp INTEGER AS LocalDateTime       -- 服务端创建时间时间戳

);

-- 查询全部消息
selectAll:
SELECT * FROM message;

-- 插入消息 用于本地的消息发送插入 没有服务端的信息
insertMessage:
INSERT INTO message ( conversation_id, from_account_id, content, client_msg_id,
 type, status, client_timestamp, sequence_id)
VALUES ( ?, ?, ?, ?, ?, ?, ?, ?);

-- 插入消息  带有服务端返回的数据
insertMessageWithMsgId:
INSERT INTO message ( conversation_id, msg_id,from_account_id, content, client_msg_id,
 type, status, server_timestamp, sequence_id)
VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?);

-- 根据 msgId 删除
deleteMessage:
DELETE FROM message WHERE msg_id = ?;

-- 根据 msgId 查询
selectMessageByMsgId:
SELECT * FROM message WHERE msg_id = ?;

-- 根据 clientMsgId 查询
selectMessageByClientMsgId:
SELECT * FROM message WHERE client_msg_id = ?;

-- 根据 conversationId 删除
deleteMessageByConversationId:
DELETE FROM message WHERE conversation_id = ?;
-- 根据 conversationId 查询 分页查询
selectMessageByConversationId:
SELECT * FROM message WHERE conversation_id = ? ORDER BY server_timestamp DESC LIMIT ? OFFSET ?;

-- 根据 conversationId 查询所有消息
selectMessagesByConversation:
SELECT * FROM message WHERE conversation_id = ? ORDER BY server_timestamp DESC  LIMIT ? ;

-- 根据 conversationId 查询所有消息并关联用户信息
selectMessagesWithUserInfoByConversation:
SELECT m.*, u.username, u.email 
FROM message m 
LEFT JOIN User u ON m.from_account_id = u.userId 
WHERE m.conversation_id = ? 
ORDER BY m.server_timestamp DESC  
LIMIT ? ;

-- 根据 conversationId 和 sequence_id 查询指定序列号之前的消息并关联用户信息
selectMessagesWithUserInfoBeforeSequence:
SELECT m.*, u.username, u.email 
FROM message m 
LEFT JOIN User u ON m.from_account_id = u.userId 
WHERE m.conversation_id = ? AND m.sequence_id < ? 
ORDER BY m.server_timestamp DESC  
LIMIT ? ;

-- 根据 conversationId 和 sequence_id 查询指定序列号之后的消息并关联用户信息
selectMessagesWithUserInfoAfterSequence:
SELECT m.*, u.username, u.email 
FROM message m 
LEFT JOIN User u ON m.from_account_id = u.userId 
WHERE m.conversation_id = ? AND m.sequence_id > ? 
ORDER BY m.server_timestamp ASC  
LIMIT ? ;

-- 根据conversationId 获取对应最大序列号
selectMaxSequenceIdByConversation:
SELECT MAX(sequence_id) FROM message WHERE conversation_id = ?;

-- 根据conversationId 获取最新的一条消息
selectLatestMessageByConversation:
SELECT * FROM message WHERE conversation_id = ? ORDER BY server_timestamp DESC LIMIT 1;

-- 根据conversationId 获取最新的一条消息并关联用户信息
selectLatestMessageWithUserInfoByConversation:
SELECT m.*, u.username, u.email 
FROM message m 
LEFT JOIN User u ON m.from_account_id = u.userId 
WHERE m.conversation_id = ? 
ORDER BY m.server_timestamp DESC 
LIMIT 1;

-- 根据conversationId 和 sequence_id 查询指定序列号之前的消息
selectMessagesBeforeSequence:
SELECT * FROM message WHERE conversation_id = ? AND sequence_id < ? ORDER BY server_timestamp DESC  LIMIT ? ;

-- 根据conversationId 和 sequence_id 查询指定序列号之后的消息
selectMessagesAfterSequence:
SELECT * FROM message WHERE conversation_id = ? AND sequence_id > ? ORDER BY server_timestamp ASC  LIMIT ? ;

-- 根据 msgId 更新消息
updateMessageByMsgId:
UPDATE message SET status = ?, server_timestamp = ?, sequence_id = ? WHERE msg_id = ?;

updateMessageByClientMsgId:
UPDATE message SET status = ? , server_timestamp = ? , sequence_id = ? ,msg_id = ? WHERE client_msg_id = ?;