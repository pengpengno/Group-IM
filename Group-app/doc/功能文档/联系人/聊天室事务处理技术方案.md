# 聊天室事务处理技术方案

## 1. 概述

本文档详细描述聊天室会话管理和消息发送的事务处理技术实现方案，解决当前实现中存在的原子性、一致性和可靠性问题。

## 2. 核心问题分析

### 2.1 当前架构缺陷

#### 现有问题代码分析
```kotlin
// 当前问题代码 (ChatRoomViewModel.kt L267-L401)
private fun performSend(content: String, pickedFile: File? = null) {
    viewModelScope.launch {
        // 问题1: 会话在此处才创建，时机过晚
        val targetConversationId = if (conversationId == null && friendId != null) {
            getOrCreatePrivateChat(currentUser.userId, friendId).conversationId
        } else {
            conversationId!!
        }

        // 问题2: 消息构建和发送分离，缺乏原子性
        val chatMessage = when {
            pickedFile != null -> chatMessageBuilder.fileMessage(...)
            else -> chatMessageBuilder.textMessage(...)
        }

        // 问题3: 离线消息和在线发送分离处理
        offlineMessageRepository.saveOfflineMessage(...)
        senderSdk.sendMessage(chatMessage) // 可能失败
        
        // 问题4: 文件上传与消息发送分离
        pickedFile?.let { file ->
            val data = filePicker.readFileBytes(file)
            fileUploadService.uploadFileData(...) // 可能失败
        }
    }
}
```

#### 主要问题总结
1. **会话创建延迟**：在发送消息时才创建会话
2. **操作非原子性**：多个关键步骤分离执行
3. **错误处理分散**：各环节失败处理不统一
4. **状态管理混乱**：缺乏统一的状态跟踪机制

## 3. 解决方案设计

### 3.1 整体架构

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   UI Layer      │───▶│ Transaction      │───▶│ Repository &    │
│ (Compose)       │    │ Manager          │    │ Network Layer   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │
                              ▼
                       ┌─────────────┐
                       │ Local Queue │
                       │ (SQLite)    │
                       └─────────────┘
```

### 3.2 核心组件设计

#### 3.2.1 事务管理器 (TransactionManager)
```kotlin
class TransactionManager @Inject constructor(
    private val transactionRepository: TransactionRepository,
    private val networkMonitor: NetworkMonitor,
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) {
    private val transactionQueue = Channel<Transaction>(Channel.UNLIMITED)
    private val scope = CoroutineScope(dispatcher + SupervisorJob())

    init {
        startProcessing()
    }

    suspend fun submitTransaction(transaction: Transaction): String {
        val transactionId = transactionRepository.insert(transaction)
        transactionQueue.send(transaction.copy(id = transactionId))
        return transactionId
    }

    private fun startProcessing() {
        scope.launch {
            transactionQueue.consumeAsFlow()
                .filter { networkMonitor.isConnected() }
                .collect { transaction ->
                    processTransaction(transaction)
                }
        }
    }

    private suspend fun processTransaction(transaction: Transaction) {
        try {
            when (transaction.type) {
                TransactionType.CREATE_SESSION -> processCreateSession(transaction)
                TransactionType.SEND_MESSAGE -> processSendMessage(transaction)
                TransactionType.UPLOAD_FILE -> processUploadFile(transaction)
            }
            transactionRepository.markSuccess(transaction.id)
        } catch (e: Exception) {
            handleTransactionError(transaction, e)
        }
    }
}
```

#### 3.2.2 会话预创建服务 (SessionPreCreationService)
```kotlin
class SessionPreCreationService @Inject constructor(
    private val conversationRepository: ConversationRepository,
    private val sessionCache: SessionCache
) {
    suspend fun ensureSessionExists(friendId: Long): Result<Long> = withContext(Dispatchers.IO) {
        try {
            // 1. 检查缓存
            sessionCache.getSessionId(friendId)?.let { return@withContext Result.success(it) }
            
            // 2. 检查本地数据库
            val localSession = conversationRepository.getLocalPrivateChat(friendId)
            if (localSession != null) {
                sessionCache.cacheSession(friendId, localSession.conversationId)
                return@withContext Result.success(localSession.conversationId)
            }
            
            // 3. 创建新会话
            val newSession = conversationRepository.createPrivateChat(friendId)
            sessionCache.cacheSession(friendId, newSession.conversationId)
            
            Result.success(newSession.conversationId)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

#### 3.2.3 统一消息发送器 (UnifiedMessageSender)
```kotlin
class UnifiedMessageSender @Inject constructor(
    private val transactionManager: TransactionManager,
    private val messageRepository: MessageRepository
) {
    suspend fun sendMessage(
        conversationId: Long,
        content: String,
        messageType: MessageType,
        attachment: Attachment? = null
    ): Result<String> {
        return withContext(Dispatchers.IO) {
            try {
                // 1. 创建本地消息记录
                val localMessage = createLocalMessage(
                    conversationId, content, messageType, attachment
                )
                
                // 2. 构建事务
                val transaction = buildSendMessageTransaction(localMessage, attachment)
                
                // 3. 提交事务
                val transactionId = transactionManager.submitTransaction(transaction)
                
                // 4. 返回客户端消息ID
                Result.success(localMessage.clientMsgId)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }

    private fun buildSendMessageTransaction(
        message: ChatMessage,
        attachment: Attachment?
    ): Transaction {
        return Transaction(
            type = TransactionType.SEND_MESSAGE,
            payload = SendMessagePayload(
                message = message,
                attachment = attachment
            ).toJson(),
            priority = TransactionPriority.HIGH,
            maxRetries = 3
        )
    }
}
```

### 3.3 数据模型设计

#### 3.3.1 事务实体
```kotlin
@Entity(tableName = "transactions")
data class TransactionEntity(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    @ColumnInfo(name = "type") val type: TransactionType,
    @ColumnInfo(name = "payload") val payload: String,
    @ColumnInfo(name = "status") val status: TransactionStatus = TransactionStatus.PENDING,
    @ColumnInfo(name = "priority") val priority: TransactionPriority = TransactionPriority.NORMAL,
    @ColumnInfo(name = "retry_count") val retryCount: Int = 0,
    @ColumnInfo(name = "max_retries") val maxRetries: Int = 3,
    @ColumnInfo(name = "created_at") val createdAt: Long = System.currentTimeMillis(),
    @ColumnInfo(name = "updated_at") val updatedAt: Long = System.currentTimeMillis(),
    @ColumnInfo(name = "error_message") val errorMessage: String? = null
)

enum class TransactionType {
    CREATE_SESSION,
    SEND_MESSAGE,
    UPLOAD_ATTACHMENT,
    UPDATE_MESSAGE_STATUS,
    DELETE_MESSAGE
}

enum class TransactionStatus {
    PENDING,
    PROCESSING,
    SUCCESS,
    FAILED,
    CANCELLED
}

enum class TransactionPriority {
    LOW,
    NORMAL,
    HIGH,
    CRITICAL
}
```

#### 3.3.2 会话缓存模型
```kotlin
data class SessionCacheEntry(
    val friendId: Long,
    val conversationId: Long,
    val cachedAt: Long = System.currentTimeMillis(),
    val expiresAt: Long = System.currentTimeMillis() + TimeUnit.HOURS.toMillis(24)
)

interface SessionCache {
    suspend fun getSessionId(friendId: Long): Long?
    suspend fun cacheSession(friendId: Long, conversationId: Long)
    suspend fun evictSession(friendId: Long)
    suspend fun clearExpiredSessions()
}
```

## 4. 实施步骤详解

### 4.1 第一阶段：基础设施搭建

#### Step 1: 数据库迁移
```kotlin
@Database(
    entities = [
        TransactionEntity::class,
        // 其他实体...
    ],
    version = 2,
    exportSchema = true
)
abstract class AppDatabase : RoomDatabase() {
    abstract fun transactionDao(): TransactionDao
    
    companion object {
        private var INSTANCE: AppDatabase? = null
        
        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database"
                )
                .addMigrations(MIGRATION_1_2) // 添加事务表迁移
                .build()
                INSTANCE = instance
                instance
            }
        }
    }
}

val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS `transactions` (
                `id` TEXT NOT NULL,
                `type` TEXT NOT NULL,
                `payload` TEXT NOT NULL,
                `status` TEXT NOT NULL,
                `priority` TEXT NOT NULL,
                `retry_count` INTEGER NOT NULL,
                `max_retries` INTEGER NOT NULL,
                `created_at` INTEGER NOT NULL,
                `updated_at` INTEGER NOT NULL,
                `error_message` TEXT,
                PRIMARY KEY(`id`)
            )
        """)
    }
}
```

#### Step 2: 核心服务实现
```kotlin
// TransactionRepository.kt
@Singleton
class TransactionRepository @Inject constructor(
    private val transactionDao: TransactionDao
) {
    suspend fun insert(transaction: Transaction): String {
        val entity = transaction.toEntity()
        transactionDao.insert(entity)
        return entity.id
    }
    
    suspend fun getPendingTransactions(): List<Transaction> {
        return transactionDao.getPendingTransactions()
            .map { it.toDomainModel() }
    }
    
    suspend fun updateStatus(id: String, status: TransactionStatus) {
        transactionDao.updateStatus(id, status.name, System.currentTimeMillis())
    }
}

// SessionCacheImpl.kt
@Singleton
class SessionCacheImpl @Inject constructor(
    private val cache: Cache<Long, SessionCacheEntry>
) : SessionCache {
    
    override suspend fun getSessionId(friendId: Long): Long? {
        return cache.getIfPresent(friendId)?.conversationId
    }
    
    override suspend fun cacheSession(friendId: Long, conversationId: Long) {
        val entry = SessionCacheEntry(friendId, conversationId)
        cache.put(friendId, entry)
    }
    
    // ... 其他实现
}
```

### 4.2 第二阶段：业务逻辑重构

#### Step 3: 修改ContactsUI导航逻辑
```kotlin
// ContactsUI.kt
@Composable
fun ContactListItem(
    userInfo: UserInfo,
    onContactClick: (Long) -> Unit
) {
    ListItem(
        modifier = Modifier.clickable {
            // 预创建会话后再导航
            onContactClick(userInfo.userId)
        }
    ) {
        // UI实现...
    }
}

// ContactsViewModel.kt
class ContactsViewModel @Inject constructor(
    private val sessionPreCreationService: SessionPreCreationService,
    private val navController: NavController
) : ViewModel() {
    
    fun onContactClick(userId: Long) {
        viewModelScope.launch {
            // 显示加载状态
            _uiState.update { it.copy(isLoading = true) }
            
            try {
                // 预创建会话
                val result = sessionPreCreationService.ensureSessionExists(userId)
                result.onSuccess { conversationId ->
                    // 跳转到聊天室
                    navController.navigate("chat/$conversationId")
                }.onFailure { error ->
                    // 处理错误
                    _uiState.update { it.copy(error = error.message) }
                }
            } finally {
                _uiState.update { it.copy(isLoading = false) }
            }
        }
    }
}
```

#### Step 4: 重构ChatRoomViewModel
```kotlin
// ChatRoomViewModel.kt
class ChatRoomViewModel @Inject constructor(
    private val unifiedMessageSender: UnifiedMessageSender,
    private val conversationRepository: ConversationRepository
) : ViewModel() {
    
    private val _sessionState = MutableStateFlow<ChatSessionState>(ChatSessionState.Initializing)
    val sessionState: StateFlow<ChatSessionState> = _sessionState.asStateFlow()
    
    fun initializeSession(conversationId: Long) {
        viewModelScope.launch {
            _sessionState.value = ChatSessionState.Loading
            
            try {
                val conversation = conversationRepository.getConversation(conversationId)
                _sessionState.value = ChatSessionState.Active(conversation)
            } catch (e: Exception) {
                _sessionState.value = ChatSessionState.Error(e)
            }
        }
    }
    
    fun sendMessage(content: String, attachment: Attachment? = null) {
        viewModelScope.launch {
            try {
                val conversationId = when (val state = sessionState.value) {
                    is ChatSessionState.Active -> state.conversation.conversationId
                    else -> throw IllegalStateException("Session not ready")
                }
                
                val result = unifiedMessageSender.sendMessage(
                    conversationId = conversationId,
                    content = content,
                    messageType = attachment?.toMessageType() ?: MessageType.TEXT,
                    attachment = attachment
                )
                
                result.onFailure { error ->
                    // 处理发送失败
                    Napier.e("Message send failed", error)
                }
            } catch (e: Exception) {
                Napier.e("Failed to send message", e)
            }
        }
    }
}
```

## 5. 错误处理与重试机制

### 5.1 智能重试策略
```kotlin
class RetryPolicy {
    companion object {
        fun exponentialBackoff(attempt: Int, baseDelay: Long = 1000L): Long {
            return (baseDelay * (2.0.pow(minOf(attempt, 5)).toLong())).coerceAtMost(30000L)
        }
        
        fun isRetryable(error: Exception): Boolean {
            return when (error) {
                is NetworkException,
                is TimeoutException,
                is SocketException -> true
                is HttpException -> error.code in 500..599
                else -> false
            }
        }
    }
}
```

### 5.2 网络状态监听
```kotlin
class NetworkMonitor @Inject constructor(
    private val context: Context
) {
    private val _isConnected = MutableStateFlow(false)
    val isConnected: StateFlow<Boolean> = _isConnected.asStateFlow()
    
    init {
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                _isConnected.value = true
            }
            
            override fun onLost(network: Network) {
                _isConnected.value = false
            }
        }
        
        connectivityManager.registerDefaultNetworkCallback(networkCallback)
    }
}
```

## 6. 测试策略

### 6.1 单元测试
```kotlin
class TransactionManagerTest {
    @Test
    fun `should process transaction successfully`() = runTest {
        // Given
        val transaction = createTestTransaction()
        val repository = mock<TransactionRepository>()
        
        // When
        val manager = TransactionManager(repository)
        val result = manager.submitTransaction(transaction)
        
        // Then
        assertTrue(result.isSuccess)
        verify(repository).insert(any())
    }
    
    @Test
    fun `should retry failed transactions`() = runTest {
        // 测试重试逻辑...
    }
}
```

### 6.2 集成测试
```kotlin
class ChatIntegrationTest {
    @Test
    fun `should handle offline message sending`() = runTest {
        // 模拟网络断开情况下发送消息的完整流程
    }
}
```

## 7. 性能优化考虑

### 7.1 内存优化
- 使用WeakReference缓存会话信息
- 及时清理过期事务记录
- 限制事务队列大小

### 7.2 数据库优化
- 为常用查询字段添加索引
- 定期清理已完成的事务记录
- 使用批量操作减少数据库访问次数

## 8. 监控与日志

### 8.1 关键指标监控
```kotlin
class TransactionMetrics {
    private val transactionCounter = Counter.build()
        .name("transactions_total")
        .help("Total number of transactions")
        .labelNames("type", "status")
        .register()
        
    private val processingTime = Histogram.build()
        .name("transaction_processing_duration_seconds")
        .help("Transaction processing time")
        .register()
        
    fun recordTransaction(type: TransactionType, status: TransactionStatus, duration: Long) {
        transactionCounter.labels(type.name, status.name).inc()
        processingTime.observe(duration.toDouble() / 1000.0)
    }
}
```

## 9. 部署与迁移

### 9.1 渐进式迁移策略
1. **灰度发布**：先在小范围用户中测试
2. **数据兼容**：保持对旧数据格式的兼容
3. **回滚机制**：准备快速回滚方案
4. **监控告警**：设置关键指标监控告警

### 9.2 回滚方案
```kotlin
class MigrationRollback {
    suspend fun rollbackToLegacy() {
        // 1. 停止新事务处理器
        transactionManager.stop()
        
        // 2. 迁移未完成事务
        migratePendingTransactionsToLegacy()
        
        // 3. 切换到旧实现
        useLegacyImplementation()
    }
}
```

## 10. 总结

本方案通过引入事务管理机制、会话预创建和统一消息发送器，从根本上解决了聊天室交互中的原子性、一致性和可靠性问题。实施后将显著提升用户体验和系统稳定性。