# 消息序列号解决方案

## 问题描述

在当前的消息系统中，每条消息都有一个 sequenceId 用于标识消息在会话中的顺序。然而，在分布式部署场景下，可能会出现以下问题：

1. 多个服务器实例同时为同一会话的消息分配 sequenceId 时可能出现冲突
2. 重启服务后，sequenceId 可能出现不连续或重复的情况
3. 需要确保 sequenceId 在会话内严格递增，作为消息的索引

## 解决方案

### 方案一：基于Redis的段式预分配优化方案

该方案通过为每个服务器实例预分配一段 sequenceId，减少对 Redis 的访问频率，同时保证全局唯一性和会话内递增性。

#### 实现原理

1. 每个服务器实例为每个会话预分配一段 sequenceId（如100个）
2. 实例内部使用本地计数器分配 sequenceId
3. 当本地段用完时，再向 Redis 申请新的段

#### 核心代码实现

```java
@Service
@RequiredArgsConstructor
@ConditionalOnProperty(name = "sequence.mode", havingValue = "redis")
public class OptimizedRedisConversationSequenceService implements ConversationSequenceService {

    private final StringRedisTemplate redisTemplate;
    private final MessageRepository messageRepository;

    /**
     * 会话序列号 Redis Key 前缀
     */
    private static final String REDIS_SEQ_KEY_PREFIX = "im:conversation:seq:";
    
    /**
     * 每次预分配的序列号段大小
     */
    private static final int SEGMENT_SIZE = 100;

    /**
     * 本地缓存当前会话的序列号段
     */
    private final ConcurrentHashMap<Long, SequenceSegment> sequenceSegments = new ConcurrentHashMap<>();

    @Override
    public long nextSequence(Long conversationId) {
        SequenceSegment segment = sequenceSegments.get(conversationId);
        
        // 如果没有缓存段或当前段已用完，则申请新段
        if (segment == null || !segment.hasNext()) {
            segment = allocateNewSegment(conversationId);
            sequenceSegments.put(conversationId, segment);
        }
        
        return segment.next();
    }

    /**
     * 为会话分配新的序列号段
     * @param conversationId 会话ID
     * @return 新的序列号段
     */
    private SequenceSegment allocateNewSegment(Long conversationId) {
        String redisKey = REDIS_SEQ_KEY_PREFIX + conversationId;
        
        // 使用Redis的INCRBY命令一次性增加段大小，获得段的结束值
        Long endValue = redisTemplate.opsForValue().increment(redisKey, SEGMENT_SIZE);
        
        // 段的起始值是结束值减去段大小加1
        long startValue = endValue - SEGMENT_SIZE + 1;
        
        return new SequenceSegment(startValue, endValue);
    }

    /**
     * 序列号段类
     */
    private static class SequenceSegment {
        private final long start;
        private final long end;
        private final AtomicLong current;

        public SequenceSegment(long start, long end) {
            this.start = start;
            this.end = end;
            this.current = new AtomicLong(start - 1); // 初始化为start-1，第一次调用next()返回start
        }

        public long next() {
            return current.incrementAndGet();
        }

        public boolean hasNext() {
            return current.get() < end;
        }
    }
}
```

### 方案二：基于数据库的同步统计器方案

该方案通过数据库实现全局同步的计数器，确保 sequenceId 的唯一性和递增性。

#### 实现原理

1. 在数据库中为每个会话维护一个 sequence 计数器记录
2. 通过数据库事务和行级锁保证分配的原子性
3. 每次分配时更新计数器并返回新值

#### 核心代码实现

```java
@Service
@ConditionalOnProperty(name = "sequence.mode", havingValue = "database")
public class DatabaseConversationSequenceService implements ConversationSequenceService {
    
    private final MessageRepository messageRepository;
    
    public DatabaseConversationSequenceService(MessageRepository messageRepository) {
        this.messageRepository = messageRepository;
    }
    
    @Override
    public long nextSequence(Long conversationId) {
        return messageRepository.incrementAndGetCurrentSequence(conversationId);
    }
}
```

对应的数据库仓库方法：

```java
@Repository
public interface MessageRepository extends JpaRepository<Message, Long> {
    
    @Modifying
    @Query(value = "INSERT INTO conversation_sequence (conversation_id, current_sequence) VALUES (?1, 0) ON DUPLICATE KEY UPDATE current_sequence = current_sequence + 1", nativeQuery = true)
    void initializeOrIncrementSequence(Long conversationId);
    
    @Query(value = "SELECT current_sequence FROM conversation_sequence WHERE conversation_id = ?1", nativeQuery = true)
    Long getCurrentSequence(Long conversationId);
    
    @Transactional
    default long incrementAndGetCurrentSequence(Long conversationId) {
        initializeOrIncrementSequence(conversationId);
        return getCurrentSequence(conversationId);
    }
    
    // ... 其他方法
}
```

## 配置选项

为了支持多种实现方式，需要在配置文件中添加相应的配置项：

```yaml
sequence:
  mode: memory # 可选值: memory, redis, database
```

## 方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| Redis段式预分配 | 性能高，减少网络访问 | 需要Redis支持 | 有Redis基础设施的分布式系统 |
| 数据库同步统计 | 强一致性，实现简单 | 性能相对较低 | 对一致性要求极高的系统 |

## 推荐方案

推荐使用**Redis段式预分配方案**，因为：

1. 保持了sequenceId在会话内的严格递增特性
2. 通过段式预分配大大减少了网络开销
3. 在分布式环境下保证了sequenceId的全局唯一性
4. 实现相对简单，维护成本低